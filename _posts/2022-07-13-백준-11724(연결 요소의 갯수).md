---

title: 백준 - 11724번 연결 요소의 갯수(Greedy, Silver2, Python) 
layout: post
description: 그래프 문제풀이
post-image: https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png

tags:
- Graph
- 
---

# 문제

방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.

---

# 입력

첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.

---

# 출력

첫째 줄에 연결 요소의 개수를 출력한다.

---



# 풀이 - 코드 참고
    from collections import deque
    import sys
    
    input = sys.stdin.readline
    
    n, m = map(int, input().split())
    graph = [[] for _ in range(n + 1)]
    
    # bfs 는 큐에서 하나씩 pop을 해가면서, pop 을 했을 때 그 원소가 가리키고 있는 원소를 또 들어갈 것임
    
    # element[1][0]
    
    def bfs(start):
        # 큐에 시작하는 노드 넣기
        queue = deque([start])
        
        # 방문 시작노드 방문 처리
        visited[start] = True
        
        # 큐가 비어있을때 까지 반복
        while queue:
            # 탐색할 노드는 큐에서 하나씩 꺼내갈것임
            node = queue.popleft()
            # i = 해당 노드가 연결되어 있는 다른 노드를 가리킨다.
            for col in graph[node]:
                # 그 i 가 방문처리 되지 않았다면
                if not visited[col]:
                    # 방문 처리 해주고,
                    visited[col] = True
                    # 큐에 삽입한다.
                    queue.append(col)
    
    for _ in range(m):
        x, y = map(int, input().split())
        graph[x].append(y)
        graph[y].append(x)
    
    # 방문처리
    visited = [False] * (1 + n)
    count = 0  # 컴포넌트 그래프 개수 저장
    
    # 1~N번 노드를 각각돌면서
    for i in range(1, n + 1):
        if not visited[i]:  # 만약 방문하지 않았다면
            if not graph[i]:  # 만약 그래프가 비어있다면
                count += 1  # 개수 1개 추가
                visited[i] = True  # 방문 처리
            else:  # 만약 그래프가 비어있지 않다면(어느 점과 연결된 점이 있다면)
                bfs(i)  # 해당 i를 시작노드로 bfs를 돈다.
                count += 1  # 연결요소 를 +1개 해준다.
    
    print(count)