---

title: 백준 - 3273번 두 수의 합(Sort, Silver 3, Python) 
layout: post
description: 정렬 문제풀이
post-image: https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png

tags:
- Sort
- Divide Conquer
---

# 문제

n개의 서로 다른 양의 정수 a1, a2, ..., an으로 이루어진 수열이 있다. ai의 값은 1보다 크거나 같고, 1000000보다 작거나 같은 자연수이다. 자연수 x가 주어졌을 때, ai + aj = x (1 ≤ i < j ≤ n)을 만족하는 (ai, aj)쌍의 수를 구하는 프로그램을 작성하시오.

# 입력

첫째 줄에 수열의 크기 n이 주어진다. 다음 줄에는 수열에 포함되는 수가 주어진다. 셋째 줄에는 x가 주어진다. (1 ≤ n ≤ 100000, 1 ≤ x ≤ 2000000)

# 출력

문제의 조건을 만족하는 쌍의 개수를 출력한다.

---

# 풀이

## 풀이 전 메모

1. ai + aj = x (1 ≤ i < j ≤ n 
   1. i 번째 수가 j 번째 수보다 작다.

2. n 은 서로다른 양수의 갯수

3. 셋째줄에 타겟넘버가 정해진다.

4. n = 10만개까지 가능

5. 정렬 후 분할정복을 해볼까 
   1. 분할정복 메서드에 넘겨줘야할 타겟은?
   2. 이러면 애초에 정렬유형의 문제가 맞나?


---

## 변수

    n : 입력 값
    array : 입력 리스트
    x : 맞춰야하는 두 수의 합
    count : x 를 만족하는 두 수의 쌍 갯수

---

## Divide-Conquer

    def divide_conquer(start, end, target):
        if start > end:
            return 0
    
        mid = (start + end) // 2
    
        if array[mid] == target:
            return 1
        elif array[mid] > target:
            return divide_conquer(start, mid - 1, target)
        elif array[mid] < target:
            return divide_conquer(mid + 1, end, target)


기초 코드는 짜봤지만 target 에 어떻게 넣어줘야할지 모르겠었다. 

---

## For-loop-1

배열의 원소를 순차 탐색하며 분할정복을돌린다.

    for item in array:
        count += divide_conquer(0, n - 1, x - item)

분할정복으로 찾아야 하는 수는, 어떤 수가 어떤 수랑 합했을 때 타겟 넘버가 되는 것이다.

그러면 target 매개변수 자리에 x 를 바로 넣는게 아니라, 그 짝을 같이 넣어주면 좋을텐데

그 방법으로 현재 배열을 하나 순회하면서 찝은 원소를 타겟넘버에서 빼는 것이다.

---

## CODE


    import sys
    
    input = sys.stdin.readline
    
    n = int(input())
    array = list(map(int, input().split()))
    array.sort()
    x = int(input())
    count = int(0)
    
    
    def divide_conquer(start, end, target):
        if start > end:
            return 0
    
        mid = (start + end) // 2
    
        if array[mid] == target:
            return 1
        elif array[mid] > target:
            return divide_conquer(start, mid - 1, target)
        elif array[mid] < target:
            return divide_conquer(mid + 1, end, target)
    
    
    # 리스트를 하나씩순회하면서, 그 원소값에 타겟하는 숫자를 빼서 매개변수로 넘겨준다.
    # --> 타겟넘버 = 배열 내에서 현재 순회 중인 값 + 분할정복 내에서 현재 순회중인 값
    # --> 분할정복 내에서 현재 순회중인 값 = 타겟넘버 - 배열 내에서 현재 순회중인 값
    
    for item in array:
        count += divide_conquer(0, n - 1, x - item)
    
    print(count // 2)

이 문제도 완벽하게 이해하고 풀이가 된게 아니다...

분할정복 돌리고 나서 출력 값이 6이 나오길래

카운트 값에 // 2 를 해주고 넣으니까 정답이 됐다.

> 좀 더 생각해보기, 그리고 정렬 유형의 문제였으니 더 정렬스럽게 풀이하기